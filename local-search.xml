<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/202207131243066710/"/>
    <url>/posts/202207131243066710/</url>
    
    <content type="html"><![CDATA[<p>Welcome to oabern’s garden, this is my first post!</p><hr><h1 id="花"><a href="#花" class="headerlink" title="花"></a>花</h1><h2 id="桃花"><a href="#桃花" class="headerlink" title="桃花"></a>桃花</h2><p><code>杜甫</code></p><blockquote><p>桃花一簇开无主，可爱深红爱浅红。<br>–《江畔独步寻花·其五》杜甫</p></blockquote><h2 id="梨花"><a href="#梨花" class="headerlink" title="梨花"></a>梨花</h2><p><code>丘为</code></p><blockquote><p>冷艳全欺雪，馀香乍入衣。<br>–《左掖梨花》丘为（唐）</p></blockquote><h1 id="庄子"><a href="#庄子" class="headerlink" title="庄子"></a>庄子</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">井蛙不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。（井蛙不语海，夏虫不语冰，凡夫不语道）<br><span class="hljs-comment">--《庄子集释》卷六下《外篇·秋水》</span><br></code></pre></td></tr></table></figure><hr><p><img src="/img/Game/"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mockito2 探索</title>
    <link href="/posts/201612133008866774/"/>
    <url>/posts/201612133008866774/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><ul><li><p>将mock的底层引擎CGLIB 更改为 ByteBuddy</p></li><li><p>为JAVA8做准备</p></li><li><p>Mockito的Junit runner 和 rule规则器 可以探测不用stubs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// detect unused stubs</span><br><span class="hljs-meta">@RunWith(MockitoJUnitRunner.class)</span><br><br><span class="hljs-comment">// don&#x27;t detect, old behaviour</span><br><span class="hljs-meta">@RunWith(MockitoJUnitRunner.Silent.class)</span><br></code></pre></td></tr></table></figure><p>or with the rule</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// detect unused stubs</span><br><span class="hljs-meta">@Rule</span> <br><span class="hljs-keyword">public</span> <span class="hljs-type">MockitoRule</span> <span class="hljs-variable">mrule</span> <span class="hljs-operator">=</span> MockitoJUnit.rule();<br><br><span class="hljs-comment">// don&#x27;t warn user about misusage, old behaviour</span><br><span class="hljs-meta">@Rule</span> <br><span class="hljs-keyword">public</span> <span class="hljs-type">MockitoRule</span> <span class="hljs-variable">mrule</span> <span class="hljs-operator">=</span> MockitoJUnit.rule().silent();<br></code></pre></td></tr></table></figure></li><li><p>对于框架的整合者或高级用户，提供新的API<code>org.mockito.listeners.MockitoListener</code>来探测无用的sutbs</p></li><li><p>新的校验控制器支持懒校验<code>Lazy verification</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Rule</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">VerificationCollector</span> <span class="hljs-variable">collector</span> <span class="hljs-operator">=</span> MockitoJUnit.collector();<br></code></pre></td></tr></table></figure><p>在一个测试方法中，所有的校验都会被执行并报告出来，即使校验报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IMethods</span> <span class="hljs-variable">methods</span> <span class="hljs-operator">=</span> mock(IMethods.class);<br><span class="hljs-comment">// Both methods are not called, but will be reported at once</span><br>verify(methods).simpleMethod();<br>verify(methods).byteReturningMethod();<br></code></pre></td></tr></table></figure><p>默认的非懒校验的方式，会在<code>simpleMethod</code>停止校验，并不会报告未进行校验的方法<code>byteReturningMethod</code></p></li><li><p>More Answers</p></li></ul><ol><li>Introducing Answers.RETURNS_SELF, which should be useful to mock builders</li><li>Java 8 friendly answers AdditionalAnswers.answer(arg1 -&gt; arg1.toString())</li></ol><ul><li>改善BDDMockito的API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BDDMockito.then(mock).should(inOrder).doSomething();<br>BDDMockito.then(mock).shouldHaveZeroInteractions();<br>BDDMockito.then(person).shouldHaveNoMoreInteractions();<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="地心历险"><a href="#地心历险" class="headerlink" title="地心历险"></a>地心历险</h2><p>揭示底层的原理</p><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>实际使用中常用的东西</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2">What’s new in Mockito2</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
      <tag>JAVA</tag>
      
      <tag>Mockito</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerMock</title>
    <link href="/posts/201612083509692517/"/>
    <url>/posts/201612083509692517/</url>
    
    <content type="html"><![CDATA[<p><strong>说明</strong><br>本文使用的开发环境为JDK1.8。<br>本文使用的框架版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- junit --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!-- Mockito 2016.8.8目前1.*为稳定版 2.*为beta --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.10.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- PowerMock  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-module-junit4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-api-mockito<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关于PowerMock的版本兼容问题，<a href="https://github.com/jayway/powermock/wiki/MockitoUsage#supported-versions">点击这里查看</a></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PowerMock可以支持EasyMock和Mockito，作为Mockito的扩展，使用PowerMock可以mock private方法，mock static方法，mock final方法，mock construction方法。PowerMock封装了部分Mockito的API，可以使用Mockito的语法来进行测试代码的编写。</p><p>Basically, PowerMock provides a class called “PowerMockito” for creating mock&#x2F;object&#x2F;class and initiating verification, and expectations, everything else you can still use Mockito to setup and verify expectation (e.g. times(), anyInt()).</p><p>All usages require @RunWith(PowerMockRunner.class) and @PrepareForTest annotated at class level.</p><hr><h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><p>核心的关键词或者关键知识点</p><hr><h2 id="地心历险（TODO）"><a href="#地心历险（TODO）" class="headerlink" title="地心历险（TODO）"></a>地心历险（TODO）</h2><p>揭示底层的原理</p><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li><p>在使用PowerMock时，必须将@RunWith(PowerMockRunner.class) and @PrepareForTest注解到类级别上</p></li><li><p>关于Argument Matcher的使用与Mockito中类似，此处不再赘述！</p></li><li><p>在下面的示例中我们没有使用 ‘import static’，以便大家更好的理解方法属于Mockito还是PowerMockito。但是我们强烈建议你在实际编写测试代码中使用‘import static’，这样的可读性更好！<br>官方原文：</p><blockquote><p>In the examples below we don’t use static imports for the method in the Mockito or PowerMockito API for better understanding of where the methods are located. However we strongly encourage you to statically import the methods in your real test cases for improved readability.</p></blockquote></li></ul><p>个人建议:由于PowerMock封装了Mockito的API，所以同时引入两个框架的static method可能会造成编译器不知道调用哪个方法。因此在使用PowerMock相关的API时，通过‘import static’引入PowerMock相关的static method，而不引入Mockito的static method，通过‘Mockito.staticMthod()’显示调用Mockito的相关API。**[tbd]**</p><ul><li>下面的示例代码只是为了展示PowerMock的用法，其中的测试方法（逻辑）可能并不适用于真实的测试代码编写工作！</li></ul><h3 id="1-Static-Method"><a href="#1-Static-Method" class="headerlink" title="1. Static Method"></a>1. Static Method</h3><h4 id="1-1-Mock-amp-Stubbing"><a href="#1-1-Mock-amp-Stubbing" class="headerlink" title="1.1 Mock &amp; Stubbing"></a>1.1 Mock &amp; Stubbing</h4><p>分为两个步骤：<br>1.调用PowerMockito.mockStatic()来mock一个静态类（如果要mock某个特定的方法，可以使用PowerMockito.spy(class)）；</p><p>2.使用Mockito.when()进行stub；</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PowerMockito.mockStatic(Static.class);<br>Mockito.when(Static.firstStaticMethod(param)).thenReturn(value);<br></code></pre></td></tr></table></figure><h4 id="1-2-Verify"><a href="#1-2-Verify" class="headerlink" title="1.2 Verify"></a>1.2 Verify</h4><p>检验行为分成两步：<br>1.首先调用PowerMockito.verifyStatic()开始校验动作</p><p>2.然后调用你想要校验的静态方法</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PowerMockito.verifyStatic(); <span class="hljs-comment">// default times is once</span><br>Static.firstStaticMethod(param); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>important</strong><br>每一个静态方法的校验前，都应该调用一次verifyStatic()。<br>官方原文：</p><blockquote><p>Important: You need to call verifyStatic() per method verification.</p></blockquote><h4 id="1-3-stub-void-static-method-to-throw-exception"><a href="#1-3-stub-void-static-method-to-throw-exception" class="headerlink" title="1.3 stub void static method to throw exception"></a>1.3 stub void static method to throw exception</h4><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// arrange</span><br>PowerMockito.doThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>()).when(StaticExample.class);<br>StaticExample.isVoidStaticMethod();     <span class="hljs-comment">//call the method stubbed to stub</span><br><br><span class="hljs-comment">// act, call the method again</span><br>StaticExample.isVoidStaticMethod();<br></code></pre></td></tr></table></figure><p>使用PowerMockito.doThrow(<del>).when(</del>)来stub，并且调用一次你要stub的方法，完成stub！</p><h3 id="2-private-method"><a href="#2-private-method" class="headerlink" title="2. private method"></a>2. private method</h3><p>对于私有方法，需要采用局部模拟（partial mocking）的手段来实现！</p><h4 id="2-1-mock-amp-stub"><a href="#2-1-mock-amp-stub" class="headerlink" title="2.1 mock &amp; stub"></a>2.1 mock &amp; stub</h4><p>先构建spy对象，然后通过PowerMockito.when(underTest, nameOfMethodToMock, ….param).thenXXX()来实现;(会在打桩时产生真实调用)<br>或者采用PowerMockito.doXXX().when(underTest, nameOfMethodToMock, …param)实现；(推荐使用，不会产生任何真实调用)</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StaticExample</span> <span class="hljs-variable">staticExampleMock</span> <span class="hljs-operator">=</span> PowerMockito.spy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticExample</span>());<br><span class="hljs-comment">// For private methods use PowerMockito.when</span><br>PowerMockito.doReturn(RETURN_VALUE).when(staticExampleMock,<span class="hljs-string">&quot;isPrivateMethod&quot;</span>,anyInt());<br><span class="hljs-comment">//when(staticExampleMock,&quot;isPrivateMethod&quot;,anyInt()).thenReturn(RETURN_VALUE);</span><br></code></pre></td></tr></table></figure><h4 id="2-2-verify"><a href="#2-2-verify" class="headerlink" title="2.2 verify"></a>2.2 verify</h4><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">verifyPrivate(staticExampleMock).invoke(<span class="hljs-string">&quot;isPrivateMethod&quot;</span>, anyInt());<br></code></pre></td></tr></table></figure><h3 id="3-Constructor"><a href="#3-Constructor" class="headerlink" title="3. Constructor"></a>3. Constructor</h3><h4 id="3-1-mock-amp-stub"><a href="#3-1-mock-amp-stub" class="headerlink" title="3.1 mock &amp; stub"></a>3.1 mock &amp; stub</h4><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PowerMockito.whenNew(MyClass.class).withNoArguments().thenThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;error message&quot;</span>));<br></code></pre></td></tr></table></figure><p>有参数的构造器也有相应的stub，形如whenNew(<del>).withXXX(</del>).thenXXX(~)，可以参见API，此处不赘述！</p><p><strong>Notice</strong>：在@PrepareForTest(Class&lt;?&gt;[] value)中，应该写入调用构造器的方法所属对象的类型！<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span><br><span class="hljs-meta">@PrepareForTest(X.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        whenNew(MyClass.class).withNoArguments().thenThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;error message&quot;</span>));<br><br>        <span class="hljs-type">X</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">X</span>();<br>        x.y(); <span class="hljs-comment">// y is the method doing &quot;new MyClass()&quot;</span><br><br>        ..<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-verify"><a href="#3-2-verify" class="headerlink" title="3.2 verify"></a>3.2 verify</h4><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PowerMockito.verifyNew(MyClass.class).withNoArguments();<br></code></pre></td></tr></table></figure><h3 id="4-final-method"><a href="#4-final-method" class="headerlink" title="4. final method"></a>4. final method</h3><p>final method 的mock, stub, verify与普通方法类似，此处不再赘述！</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/OAbern/mock-demo">鄙人编写的代码示例</a>（部分来自官网示例，适量修改，并添加额外的示例）<br><a href="https://github.com/jayway/powermock">PowerMock On Github</a><br><a href="http://my.oschina.net/u/1433482/blog/645155#comment-list">使用PowerMock进行Mock测试</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-powermock/">PowerMock简介</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
      <tag>JAVA</tag>
      
      <tag>PowerMock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mockito</title>
    <link href="/posts/201612072734635843/"/>
    <url>/posts/201612072734635843/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Dan North, the originator of Behavior-Driven Development wrote this back in 2008:<br>“We decided during the main conference that we should use JUnit 4 and Mockito because we think they are the future of TDD and mocking in Java”</p></blockquote><hr><p><strong>说明</strong><br>本文章中的示例使用的开发环境为JDK1.8！<br>Mockito的版本信息如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.10.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><p>文章中的示例部分来自<a href="https://dzone.com/refcardz/mockito">Mockito Dzone Reference Card</a></p><p><strong>Warning</strong>：文章中的示例只是为了展示Mockito的语法和特性，在实际的测试编码中，我们可能不会使用示例的用法（测试逻辑）！<br>官方原文：</p><blockquote><p>Warning: Note that the examples in this Refcardwere created to demonstrate behaviors of Mockito in a specific context. Of course, when writing the test for your codebase, there is no need to ensure that mocks are stubbed correctly.</p></blockquote><p>鄙人在Github上修改了部分示例，并且写了一些其他的示例（实际测试代码中用法）！<a href="https://github.com/OAbern/mock-demo">传送门</a></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mockito是一个模拟测试框架。在一个被测试的对象（功能）A中，它通常需要与其他的对象（功能）B进行一些交互，我们把A称作被测试对象（tested object），把B称作协作者（collaborators）。那么在测试环境中，这些协作者都需要被创建，以便被测试对象可以使用它们。为了使测试代码简化以及满足上下文执行环境，我们通常使用测试替身（test double）来代替这些协作者，测试替身看上去和原始的协作者一样，但是却不依赖其他对象，而且可以执行预期行为，记录他们的交互行为（interactions，可以理解成方法调用）</p><hr><h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><p><strong>TDD</strong> : Test-Driven Development</p><p><strong>BDD</strong> : Behavior-Driven Development</p><p><strong>Mock</strong> : 模拟对象，可以理解成Mockito框架帮我们自动生成的数据。通过mock产生的对象有以下的能力：1.可以通过编程产生预期行为；2.在对象的生命周期内可以校验它的交互行为（方法调用）；</p><blockquote><p>原文参考：Mock - an object with the ability to a) have a programmed expected behavior, and b) verify the interactions occurring in its lifetime (this object is usually created with the help of mocking framework)</p></blockquote><p><strong>Stub</strong> : 存根？桩？可以理解成通过硬编码的方式预期定义行为（方法），将会产生特定的结果，屏蔽原本行为（方法）的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**举例，伪代码描述*/</span><br><br><span class="hljs-comment">//define a method</span><br><span class="hljs-keyword">public</span> string <span class="hljs-title function_">sayABC</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ABC&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//stubbing</span><br>define when call sayABC the <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CBA&quot;</span><br><br><span class="hljs-comment">//act</span><br>sayABC();   <span class="hljs-comment">//call then we got &quot;CBA&quot; not &quot;ABC&quot;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>原文参考：Stub - an object with hardcoded behavior suitable for a given test (or a group of tests)</p></blockquote><p><strong>Spy</strong> : mock的代理对象，当方法被stub的时候，调用stub的定义行为（方法实现被忽略）；当方法没有被stub时，调用真实对象的行为（调用真实方法的逻辑实现）。此对象一般不由mock生成，而是自己编码new，再通过spy包装成mock</p><blockquote><p>原文参考：Spy - a mock created as a proxy to an existing real object; some methods can be stubbed, while the un-stubbed ones are forwarded to the covered object</p></blockquote><p><a href="https://en.wikipedia.org/wiki/Test_double"><strong>Test Doubles</strong></a>：测试替身，包括5个类型stub，mock，spy，fake，dummy。</p><hr><h2 id="地心历险-待研究"><a href="#地心历险-待研究" class="headerlink" title="地心历险(待研究)"></a>地心历险(待研究)</h2><p>揭示底层的原理</p><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>编写测试用例，一般分为三个阶段：</p><table><thead><tr><th>Section name</th><th>Responsibility</th></tr></thead><tbody><tr><td>arrange (given)</td><td>SUT and mocks initialization and configuration</td></tr><tr><td>act (when)</td><td>An operation which is a subject to testing；preferably only one operation on an SUT</td></tr><tr><td>assert (then)</td><td>The assertion and verification phase</td></tr></tbody></table><p>arrange-act-assert模式对应的语法为：when(<del>).thenXXX(</del>)<br>given-when-then模式(对应BDD形式)对应的语法为：given(<del>).willXXX(</del>)<br>官方大部分DEMO使用given-when-then模式，而且也推荐使用这种模式</p><blockquote><p>官方原文: given-when-then comments make intentions of tests clearer.</p></blockquote><h3 id="2-简例"><a href="#2-简例" class="headerlink" title="2. 简例"></a>2. 简例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.testng.annotations.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.mockito.Mockito.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.testng.Assert.assertEquals;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleStubbingTest</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TEST_NUMBER_OF_LEAFS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>  <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldReturnGivenValue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// arrange</span><br>      <span class="hljs-type">Flower</span> <span class="hljs-variable">flowerMock</span> <span class="hljs-operator">=</span> mock(Flower.class);<br>      when(flowerMock.getNumberOfLeafs()).thenReturn(TEST_NUMBER_OF_LEAFS);<br>  <br>      <span class="hljs-comment">// act</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">numberOfLeafs</span> <span class="hljs-operator">=</span> flowerMock.getNumberOfLeafs();<br>      <br>      <span class="hljs-comment">// assert</span><br>      assertEquals(numberOfLeafs, TEST_NUMBER_OF_LEAFS);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.mockito.Mockito.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.mockito.BDDMockito.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleStubbingTest</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TEST_NUMBER_OF_LEAFS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>  <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldReturnGivenValueUsingBDDSemantics</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//given</span><br>      <span class="hljs-type">Flower</span> <span class="hljs-variable">flowerMock</span> <span class="hljs-operator">=</span> mock(Flower.class);<br>      given(flowerMock.getNumberOfLeafs()).willReturn(TEST_NUMBER_OF_LEAFS);<br>  <br>      <span class="hljs-comment">//when</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">numberOfLeafs</span> <span class="hljs-operator">=</span> flowerMock.getNumberOfLeafs();<br>      <br>      <span class="hljs-comment">//then</span><br>      assertEquals(numberOfLeafs, TEST_NUMBER_OF_LEAFS);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-参数匹配"><a href="#3-参数匹配" class="headerlink" title="3. 参数匹配"></a>3. 参数匹配</h3><p><code>（Argument Matching）</code><br>Mockito默认使用equals()来匹配参数。通常我们需要一个宽范围的参数匹配，Mockito的org.mockito.Matchers类中提供了一套内置的匹配器（Matcher）。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">given(plantSearcherMock.smellyMethod(anyInt(), contains(<span class="hljs-string">&quot;asparag&quot;</span>), eq(<span class="hljs-string">&quot;red&quot;</span>))).willReturn(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//given(plantSearcherMock.smellyMethod(anyInt(), contains(&quot;asparag&quot;), &quot;red&quot;)).willReturn(true);</span><br><br><span class="hljs-comment">//incorrect - would throw an exception</span><br></code></pre></td></tr></table></figure><p>如果有一个参数使用了匹配器，则所有的参数必须都使用匹配器，否则将会抛出异常！示例代码中注释掉的部分会抛出异常！</p><p>自定义的参数匹配器需要继承org.mockito.ArgumentMatcher抽象类，并且实现matches方法。然后调用argThat(org.hamcrest.Matcher<T> matcher)方法。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">given(schedulerMock.getNumberOfPlantsScheduledOnDate(<br>  argThat(haveHourFieldEqualTo(<span class="hljs-number">7</span>)))).willReturn(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//with the util method to create a matcher</span><br><span class="hljs-keyword">private</span> ArgumentMatcher <span class="hljs-title function_">haveHourFieldEqualTo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hour)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArgumentMatcher</span>() &#123;<br>  <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(Object argument)</span> &#123;<br>          <span class="hljs-keyword">return</span> ((Date) argument).getHours() == hour;<br>      &#125;<br>  &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-调用Void方法"><a href="#4-调用Void方法" class="headerlink" title="4. 调用Void方法"></a>4. 调用Void方法</h3><p><code>Stubbing Void Methods</code><br>void Methods 应该使用 willXXX..given 或者 doXXX..when.来进行stubbing<br>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test(expectedExceptions = WaterException.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldStubVoidMethod</span><span class="hljs-params">()</span> &#123;<br><br>  <span class="hljs-type">WaterSource</span> <span class="hljs-variable">waterSourceMock</span> <span class="hljs-operator">=</span> mock(WaterSource.class);<br>  doThrow(WaterException.class).when(waterSourceMock).doSelfCheck();<br><br>  <span class="hljs-comment">//the same with BDD semantics</span><br>  <span class="hljs-comment">//willThrow(WaterException.class).given(waterSourceMock).doSelfCheck();</span><br><br>  waterSourceMock.doSelfCheck();<br><br>  <span class="hljs-comment">//exception expected</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-自定义返回器"><a href="#5-自定义返回器" class="headerlink" title="5. 自定义返回器"></a>5. 自定义返回器</h3><p><code>Stubbing With a Custom Answer</code><br>极少的情况会使用自己的处理逻辑来指定预期行为的结果(也就是given..willReturn(Custom Answer)中的Answer).Mockito还是提供了<code>org.mockito.stubbing.Answer&lt;Object&gt;</code>的接口来实现这个功能，你只需实现该接口中的answer方法。</p><p><strong>Warning</strong>：如果需要使用Custom Answer，可能预示着被测代码太复杂，需要重构！<br>官方原文：</p><blockquote><p>Warning: The need to use a custom answer may indicate that tested code is too complicated and should be re-factored.</p></blockquote><h3 id="6-检验行为"><a href="#6-检验行为" class="headerlink" title="6. 检验行为"></a>6. 检验行为</h3><p><code>（Verifying Behavior）</code><br>在一个mock对象的生命周期内，它会记住本身所有的操作。在被测系统（SUT）中，这些操作应该可以被轻易校验。Mockito中可以使用Mockito.verify(T mock)这个基础形式来进行校验<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">WaterSourcewaterSourceMock = mock(WaterSource.class);<br><br>waterSourceMock.doSelfCheck();<br><br>verify(waterSourceMock).doSelfCheck();      <span class="hljs-comment">//默认校验一次调用</span><br></code></pre></td></tr></table></figure><p>Mockito提供了一些有意义的校验模式，你也可以创建自定义校验模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">verify(waterSourceMock,never()).doSelfCheck();<br><br>verify(waterSourceMock,times(<span class="hljs-number">2</span>)).getWaterPressure();<br><br>verify(waterSourceMock,atLeast(<span class="hljs-number">1</span>)).getWaterTemperature();<br></code></pre></td></tr></table></figure><h3 id="7-校验调用顺序"><a href="#7-校验调用顺序" class="headerlink" title="7. 校验调用顺序"></a>7. 校验调用顺序</h3><p><code>（Verifying Call Order）</code><br>Mockito可以让你校验调用的顺序，你可以创建一组mocks，然后在组内校验所有的调用顺序。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldVerifyInOrderThroughDifferentMocks</span><span class="hljs-params">()</span>&#123;<br><br>  WaterSourcewaterSource1=mock(WaterSource.class);<br>  WaterSourcewaterSource2=mock(WaterSource.class);<br><br>  waterSource1.doSelfCheck();<br>  waterSource2.getWaterPressure();<br>  waterSource1.getWaterTemperature();<br><br>  InOrderinOrder=inOrder(waterSource1,waterSource2);<br>  inOrder.verify(waterSource1).doSelfCheck();<br>  inOrder.verify(waterSource2).getWaterPressure();<br>  inOrder.verify(waterSource1).getWaterTemperature();<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-真实调用"><a href="#8-真实调用" class="headerlink" title="8. 真实调用"></a>8. 真实调用</h3><p><code>Spying on Real Objects</code><br>在Mockito中，你可以使用真实的对象来代替mock，从而使部分方法可以stubbed。通常我们不需要使用spy一个真实的对象，这可能是代码异味（code smell）的信号。但在一些特殊的情况下（比如使用了遗留代码，或者IOC容器），纯mock对象可能不能进行测试。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldStubMethodAndCallRealNotStubbedMethod</span><span class="hljs-params">()</span> &#123;<br><br>  <span class="hljs-type">Flower</span> <span class="hljs-variable">realFlower</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Flower</span>();<br>  realFlower.setNumberOfLeafs(ORIGINAL_NUMBER_OF_LEAFS);<br>  FlowerflowerSpy=spy(realFlower);<br>  willDoNothing().given(flowerSpy).setNumberOfLeafs(anyInt());<br><br>  flowerSpy.setNumberOfLeafs(NEW_NUMBER_OF_LEAFS);  <span class="hljs-comment">//stubbed,and should do nothing</span><br><br>  verify(flowerSpy).setNumberOfLeafs(NEW_NUMBER_OF_LEAFS);<br>  assertEquals(flowerSpy.getNumberOfLeafs(),ORIGINAL_NUMBER_OF_LEAFS);       <span class="hljs-comment">//value was not changed</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>当使用spy时，必须使用willXXX..given&#x2F; doXXX..的形式来stubbing，它可以在stub期间防止真实方法方法被调用</p><p><strong>Warning</strong>：当使用spy时，Mockito创建了真实对象的一份拷贝，因此所有的交互行为应该被传递到被创建的spy对象上<br>官方原文：</p><blockquote><p>Warning: While spying, Mockito creates a copy of a real object, and therefore all interactions should be passed using the created spy.</p></blockquote><h3 id="9-注解"><a href="#9-注解" class="headerlink" title="9. 注解"></a>9. 注解</h3><p><code>Annotations</code><br>Mockito提供三个注解来简化用静态方法创建mock对象的工作 – @Mock, @Spy, @Captor；注解@InjectMocks可以简化mock和spy对象的注入，它可以通过构造器注入，setter方法注入，field赋值注入。</p><p>使用注解的功能要调用MockitoAnnotations.initMocks(testClass)（通常在@Before的方法中调用），或者使用MockitoJUnit4Runner来作为junit runner</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//with constructor: PlantWaterer(WaterSource waterSource,</span><br><span class="hljs-comment">// WateringScheduler wateringScheduler) &#123;...&#125;</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockInjectingTest</span> &#123;<br><br>  <span class="hljs-meta">@Mock</span><br>  <span class="hljs-keyword">private</span> WaterSource waterSourceMock;<br><br>  <span class="hljs-meta">@Spy</span><br>  <span class="hljs-keyword">private</span> WateringScheduler wateringSchedulerSpy;<br><br>  <span class="hljs-meta">@InjectMocks</span><br>  <span class="hljs-keyword">private</span> PlantWaterer plantWaterer;<br><br>  <span class="hljs-meta">@BeforeMethod</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>      MockitoAnnotations.initMocks(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldInjectMocks</span><span class="hljs-params">()</span> &#123;<br>      assertNotNull(plantWaterer.getWaterSource());<br>      assertNotNull(plantWaterer.getWateringScheduler());<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Annotation</th><th>Responsibility</th></tr></thead><tbody><tr><td>@Mock</td><td>Creates a mock of a given type</td></tr><tr><td>@Spy</td><td>Creates a spy of a given object</td></tr><tr><td>@Captor</td><td>Creates an argument captor of a given type</td></tr><tr><td>@InjectMocks</td><td>Creates an object of a given type and injects mocks and spies existing in a test</td></tr></tbody></table><h3 id="10-修改默认返回值"><a href="#10-修改默认返回值" class="headerlink" title="10. 修改默认返回值"></a>10. 修改默认返回值</h3><p><code>（Changing the Mock Default Return Value）</code></p><p>Mockito使我们可以选择生成mock对象的默认值</p><table><thead><tr><th>Default Answer</th><th>Description</th></tr></thead><tbody><tr><td>RETURNS_DEFAULTS</td><td>Returns a default “empty” value (e.g., null, 0, false, empty collection) - used by default</td></tr><tr><td>RETURNS_SMART_NULLS</td><td>Creates a spy of a given object</td></tr><tr><td>RETURNS_MOCKS</td><td>Returns a default “empty” value, but a mock instead of null</td></tr><tr><td>RETURNS_DEEP_STUBS</td><td>Allows for a simple deep stubbing (e.g., Given(ourMock.getObject().getValue()).willReturn(s))</td></tr><tr><td>CALLS_REAL_METHODS</td><td>Call a real method of spied object</td></tr></tbody></table><blockquote><p>mock(clazz, Mockito.${Default Answer})</p></blockquote><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>依照本人的理解，在真正编写测试代码时，我们应该分清当前单元测试的目的，以及它所依赖的方法调用。然后在given阶段，mock各种依赖的对象，并且stub各种依赖对象的预期行为；when阶段进行测试目的的执行，也就是测试对象真实的调用行为；then阶段进行verify和assert。</p><hr><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>引用官方说明:<br><strong>Limitations</strong></p><ul><li>Mockito has a few limitations worth remembering. They are generally technical restrictions, but Mockito authors believe using hacks to work around them would encourage people to write poorly testable code. <strong>Mockito cannot</strong> :<ul><li>mock final classes</li><li>mock enums</li><li>mock final methods</li><li>mock static methods</li><li>mock private methods</li><li>mock hashCode() and equals()</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/OAbern/mock-demo">鄙人编写的代码示例</a>（部分来自官网示例，适量修改，并添加额外的示例）<br><a href="http://mockito.org/">Mockito官网</a><br><a href="https://github.com/mockito/mockito">Mockito On Github</a><br><a href="https://dzone.com/refcardz/mockito">Mockito Dzone Reference Card</a><br><a href="http://stackoverflow.com/documentation/mockito/2055/introduction-to-mockito#t=201608090656397575575">Introduction to mockito</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
      <tag>JAVA</tag>
      
      <tag>Mockito</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
